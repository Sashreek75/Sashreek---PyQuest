
import { Quest, Achievement } from './types';

export const INITIAL_ACHIEVEMENTS: Achievement[] = [
  { id: 'first_step', title: 'Hello World', description: 'Initialized your first session in PyQuest.', icon: 'ðŸš€', rarity: 'Common' },
  { id: 'streak_3', title: 'Triple Threat', description: 'Maintained a 3-day learning streak.', icon: 'ðŸ”¥', rarity: 'Common' },
  { id: 'math_wizard', title: 'NumPy Ninja', description: 'Solved your first matrix-based quest.', icon: 'ðŸ¥·', rarity: 'Rare' },
  { id: 'ai_architect', title: 'Neural Architect', description: 'Built a multi-layer neural network from scratch.', icon: 'ðŸ§ ', rarity: 'Epic' },
  { id: 'transformer_master', title: 'Attention Seeker', description: 'Implemented the Attention mechanism.', icon: 'âœ¨', rarity: 'Legendary' }
];

export const QUESTS: Quest[] = [
  {
    id: 'py-1',
    title: 'The Alchemy of Types',
    category: 'Python Foundations',
    difficulty: 'Beginner',
    description: 'Data is the lifeblood of AI. Master the fundamental primitives.',
    longDescription: 'In this module, we transition from simple strings to complex numeric types. Understanding how Python handles memory and precision is critical when preparing tensors for deep learning models. We will explore the nuances of integer versus float representations and f-string interpolation for model logging.',
    objective: 'Create an intelligent profile system that calculates a user\'s biological age in seconds and formats it as a scientific string for audit logging.',
    startingCode: `name = "Researcher"\nage_years = 20\n# TODO: Calculate age in seconds (365.25 days/year)\nage_seconds = 0\nprint(f"Subject: {name} | Lifecycle: {age_seconds}s")`,
    solutionHint: 'Multiply age_years by 365.25 * 24 * 60 * 60.',
    topics: ['Variables', 'Integers', 'f-strings'],
    estimatedMinutes: 10,
    xpReward: 250,
    quiz: [{ question: 'Python is interpreted.', options: ['True', 'False'], correctAnswer: 0, explanation: 'Python code is executed by an interpreter line by line.' }],
    technicalPrerequisites: []
  },
  {
    id: 'py-2',
    title: 'Logic Gates: The Sentinel',
    category: 'Python Foundations',
    difficulty: 'Beginner',
    description: 'Machines only "think" through decisions. Master boolean flow control.',
    longDescription: 'Conditional logic is the precursor to decision trees. In this module, we implement a multi-condition security gate.',
    objective: 'Write a security sentinel script that permits entry only if the subject has clearance AND is age >= 18.',
    startingCode: `clearance = True\nage = 25\naccess_granted = False`,
    solutionHint: 'Use: if clearance and age >= 18:',
    topics: ['Conditionals', 'Boolean Logic'],
    estimatedMinutes: 15,
    xpReward: 300,
    quiz: [{ question: 'Which checks for equality?', options: ['=', '=='], correctAnswer: 1, explanation: '== is the equality operator.' }],
    technicalPrerequisites: ['py-1']
  },
  {
    id: 'py-3',
    title: 'Functional Mapping',
    category: 'Python Foundations',
    difficulty: 'Beginner',
    description: 'Avoid redundant logic. Encapsulate your algorithms into reusable functions.',
    longDescription: 'Reusable code blocks (functions) are the modules of any ML pipeline. Learn to pass arguments and return computed states.',
    objective: 'Define a function "calculate_mse" that takes an error and returns the square of that error.',
    startingCode: `def calculate_mse(error):\n    # TODO: Return error squared\n    pass`,
    solutionHint: 'return error ** 2',
    topics: ['Functions', 'Arguments', 'Return Values'],
    estimatedMinutes: 15,
    xpReward: 350,
    quiz: [],
    technicalPrerequisites: ['py-2']
  },
  {
    id: 'py-4',
    title: 'Structure & Iteration',
    category: 'Python Foundations',
    difficulty: 'Intermediate',
    description: 'Process batches of data using Lists and Dictionaries.',
    longDescription: 'Iterating over datasets is central to training. Learn how to map functions across lists and store metadata in key-value pairs.',
    objective: 'Create a list of 5 errors, and use a loop to square each one into a new list called "squared_errors".',
    startingCode: `errors = [0.5, 0.1, -0.4, 0.9, 0.2]\nsquared_errors = []\n# TODO: Iterate and append squared values`,
    solutionHint: 'for e in errors: squared_errors.append(e**2)',
    topics: ['Lists', 'Loops', 'Dictionaries'],
    estimatedMinutes: 20,
    xpReward: 400,
    quiz: [],
    technicalPrerequisites: ['py-3']
  },
  {
    id: 'ds-1',
    title: 'The NumPy Array Matrix',
    category: 'Mathematical Logic',
    difficulty: 'Intermediate',
    description: 'Vanilla Python is too slow for AI. Harness vectorized operations.',
    longDescription: 'NumPy is the foundation. Learn ndarrays, shape manipulation, and broadcasting for high-performance computing.',
    objective: 'Create a 5x5 matrix of zeros and set the central value [2,2] to 1.0.',
    startingCode: `import numpy as np\n# TODO: Create 5x5 matrix and modify center\nmatrix = None`,
    solutionHint: 'mat = np.zeros((5,5)); mat[2,2] = 1.0',
    topics: ['NumPy', 'Matrix', 'Vectorization'],
    estimatedMinutes: 20,
    xpReward: 450,
    quiz: [],
    technicalPrerequisites: ['py-4']
  },
  {
    id: 'ds-2',
    title: 'DataFrame Engineering',
    category: 'Data Engineering',
    difficulty: 'Intermediate',
    description: 'Pandas is the data scientist\'s Swiss Army knife.',
    longDescription: 'Manipulate tabular data, handle missing values, and perform group-by operations to extract insights from raw CSVs.',
    objective: 'Create a Pandas DataFrame with columns "feature" and "label", then filter it for features > 0.5.',
    startingCode: `import pandas as pd\n# TODO: Create and filter DataFrame\ndf = None`,
    solutionHint: 'df[df["feature"] > 0.5]',
    topics: ['Pandas', 'DataFrames', 'Filtering'],
    estimatedMinutes: 25,
    xpReward: 500,
    quiz: [],
    technicalPrerequisites: ['ds-1']
  },
  {
    id: 'ml-1',
    title: 'Linear Regressor',
    category: 'Classical ML',
    difficulty: 'Intermediate',
    description: 'The simplest predictive model. Find the line of best fit.',
    longDescription: 'Learn the math behind least squares and how to implement a linear regression pipeline using Scikit-Learn.',
    objective: 'Initialize a LinearRegression model, "fit" it to some dummy data, and return the predicted slope.',
    startingCode: `from sklearn.linear_model import LinearRegression\nimport numpy as np\nX = np.array([[1], [2], [3]])\ny = np.array([2, 4, 6])\n# TODO: Fit model and get coef_`,
    solutionHint: 'model = LinearRegression().fit(X, y); slope = model.coef_',
    topics: ['Regression', 'Scikit-Learn', 'Fitting'],
    estimatedMinutes: 30,
    xpReward: 550,
    quiz: [],
    technicalPrerequisites: ['ds-2']
  },
  {
    id: 'ml-2',
    title: 'Decision Entropy',
    category: 'Classical ML',
    difficulty: 'Intermediate',
    description: 'Tree-based models and the concept of Information Gain.',
    longDescription: 'Understand how Decision Trees split data to minimize Gini Impurity or Entropy.',
    objective: 'Implement a DecisionTreeClassifier on the Iris dataset and score its accuracy.',
    startingCode: `from sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n# TODO: Load data, fit, and score`,
    solutionHint: 'clf = DecisionTreeClassifier().fit(X, y); acc = clf.score(X, y)',
    topics: ['Entropy', 'Classification', 'Trees'],
    estimatedMinutes: 30,
    xpReward: 600,
    quiz: [],
    technicalPrerequisites: ['ml-1']
  },
  {
    id: 'ml-3',
    title: 'Cluster Analysis',
    category: 'Classical ML',
    difficulty: 'Intermediate',
    description: 'Unsupervised learning and finding patterns without labels.',
    longDescription: 'Explore K-Means clustering and the "Elbow Method" to determine the optimal number of groups.',
    objective: 'Implement K-Means clustering with k=3 on synthetic data points.',
    startingCode: `from sklearn.cluster import KMeans\n# TODO: Cluster data`,
    solutionHint: 'kmeans = KMeans(n_clusters=3).fit(data)',
    topics: ['K-Means', 'Unsupervised', 'Clusters'],
    estimatedMinutes: 30,
    xpReward: 650,
    quiz: [],
    technicalPrerequisites: ['ml-2']
  },
  {
    id: 'dl-1',
    title: 'The Artificial Neuron',
    category: 'Deep Learning',
    difficulty: 'Intermediate',
    description: 'Mimicking biology with weight, bias, and sum.',
    longDescription: 'The building block of neural networks. Learn the math: z = w*x + b.',
    objective: 'Calculate the output of a neuron given x=2.0, w=0.5, b=1.0.',
    startingCode: `x, w, b = 2.0, 0.5, 1.0\n# TODO: Calculate output z\nz = 0`,
    solutionHint: 'z = (x * w) + b',
    topics: ['Linearity', 'Weights', 'Bias'],
    estimatedMinutes: 20,
    xpReward: 700,
    quiz: [],
    technicalPrerequisites: ['ml-3']
  },
  {
    id: 'dl-2',
    title: 'ReLU Activation',
    category: 'Deep Learning',
    difficulty: 'Intermediate',
    description: 'Introduction to Non-Linearity.',
    longDescription: 'Why networks need activation functions to learn complex patterns.',
    objective: 'Implement the ReLU function: return max(0, x).',
    startingCode: `def relu(x):\n    # TODO: Implement ReLU logic\n    pass`,
    solutionHint: 'return x if x > 0 else 0',
    topics: ['Non-linearity', 'ReLU', 'Gradients'],
    estimatedMinutes: 20,
    xpReward: 750,
    quiz: [],
    technicalPrerequisites: ['dl-1']
  },
  {
    id: 'dl-3',
    title: 'Gradient Descent',
    category: 'Deep Learning',
    difficulty: 'Advanced',
    description: 'Optimization: Sliding down the loss curve.',
    longDescription: 'The engine of learning. Learn how to update weights based on the derivative of the loss function.',
    objective: 'Implement a single weight update step: w = w - lr * gradient.',
    startingCode: `w, lr, grad = 0.5, 0.1, 0.2\n# TODO: Update w\nw_new = 0`,
    solutionHint: 'w_new = w - (lr * grad)',
    topics: ['Optimization', 'Learning Rate', 'Calculus'],
    estimatedMinutes: 40,
    xpReward: 800,
    quiz: [],
    technicalPrerequisites: ['dl-2']
  },
  {
    id: 'nn-1',
    title: 'Vision: Convolutional Layers',
    category: 'Neural Architectures',
    difficulty: 'Advanced',
    description: 'Spatial hierarchy and feature extraction in images.',
    longDescription: 'Learn how filters glide across images to detect edges, textures, and objects.',
    objective: 'Simulate a 2x2 max pooling operation on a 4x4 matrix.',
    startingCode: `import numpy as np\n# TODO: 4x4 -> 2x2 max pooling`,
    solutionHint: 'Divide matrix into 2x2 blocks and take max of each.',
    topics: ['CNN', 'Pooling', 'Kernels'],
    estimatedMinutes: 45,
    xpReward: 850,
    quiz: [],
    technicalPrerequisites: ['dl-3']
  },
  {
    id: 'nn-2',
    title: 'RNN: Temporal Memory',
    category: 'Neural Architectures',
    difficulty: 'Advanced',
    description: 'Processing sequences and time-series data.',
    longDescription: 'Recursive loops allow networks to remember previous inputs. Explore LSTMs and GRUs.',
    objective: 'Describe the vanishing gradient problem in vanilla RNNs.',
    startingCode: `answer = ""\n# TODO: Briefly explain vanishing gradients`,
    solutionHint: 'Gradients get smaller as they propagate back through long sequences.',
    topics: ['RNN', 'LSTM', 'Sequences'],
    estimatedMinutes: 45,
    xpReward: 900,
    quiz: [],
    technicalPrerequisites: ['nn-1']
  },
  {
    id: 'trans-1',
    title: 'Self-Attention Mechanism',
    category: 'LLM & Transformers',
    difficulty: 'Expert',
    description: 'The "Attention is All You Need" revolution.',
    longDescription: 'The core of GPT and BERT. Learn about Query, Key, and Value vectors and how they compute similarity weights.',
    objective: 'Implement a dot-product attention scoring function.',
    startingCode: `import numpy as np\ndef attention(q, k, v):\n    # TODO: Calculate softmax(q dot k.T) dot v\n    pass`,
    solutionHint: 'Score = Softmax(Q @ K.T) @ V',
    topics: ['Transformers', 'Attention', 'Scaling'],
    estimatedMinutes: 60,
    xpReward: 1200,
    quiz: [],
    technicalPrerequisites: ['nn-2']
  },
  {
    id: 'ops-1',
    title: 'Inference Pipelines',
    category: 'MLOps & Deployment',
    difficulty: 'Advanced',
    description: 'Moving from the lab to production.',
    longDescription: 'Packaging models with FastAPI or Flask, handling load, and monitoring drift.',
    objective: 'Write a basic Flask endpoint that returns a prediction from a pre-loaded model.',
    startingCode: `from flask import Flask, request\napp = Flask(__name__)\n# TODO: Create /predict route`,
    solutionHint: '@app.route("/predict", methods=["POST"])',
    topics: ['API', 'Deployment', 'Monitoring'],
    estimatedMinutes: 50,
    xpReward: 1000,
    quiz: [],
    technicalPrerequisites: ['trans-1']
  }
];
